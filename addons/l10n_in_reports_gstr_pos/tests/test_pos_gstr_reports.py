# Part of Odoo. See LICENSE file for full copyright and licensing details.
import odoo

from datetime import date
from freezegun import freeze_time

from odoo.fields import Command
from .common import TestInGstrPosBase


@odoo.tests.tagged('post_install_l10n', 'post_install', '-at_install')
class TestInGstrPosGSTR(TestInGstrPosBase):
    """
    Test class for GSTR-related POS functionality.
    """

    @freeze_time('2023-05-20')
    def test_gstr1_json_generation_with_pos_refund_order(self):
        """Test case for partial refund and GSTR1 JSON generation."""
        with self.with_pos_session():
            # Step 1: Create an order with two products
            order = self._create_order({
                'pos_order_lines_ui_args': [
                    (self.product_a, 2.0),  # Buying 2 units of product_a
                    (self.product_b, 2.0),  # Buying 2 units of product_b
                ],
                'payments': [(self.bank_pm1, 630.0)],  # Payment of 630
            })

            # Step 2: Create a refund for one product line
            self._create_order({
                'pos_order_lines_ui_args': [
                    {
                        'product': self.product_b,
                        'quantity': -1.0,  # Refund 1 unit of product_b
                        'refunded_orderline_id': order.lines[1].id,
                    },
                ],
                'payments': [(self.bank_pm1, -210.0)],  # Refund of 210
            })

        # Retrieve the GSTR1 JSON report generated by POS session closure
        generated_gstr1_json = self.gstr1_report._get_l10n_in_gstr1_json()

        # Assert GSTR1 JSON matches the expected data
        expected_gstr1_pos_refund_response = self._read_mock_json('gstr1_pos_refund_expected_response.json')
        self.assertDictEqual(generated_gstr1_json, expected_gstr1_pos_refund_response)

    @freeze_time('2023-05-20')
    def test_gstr1_json_generation_with_pos_order_invoice(self):
        """Test GSTR1 JSON generation with POS invoice and order closure."""
        with self.with_pos_session():
            # Create a POS order without an invoice, simulating basic sale and payment
            self._create_order({
                'pos_order_lines_ui_args': [
                    (self.product_a, 2.0),  # 2 units of product A
                    (self.product_b, 2.0),  # 2 units of product B
                ],
                'payments': [(self.bank_pm1, 630.0)],  # Payment of 630 through bank payment method
            })
            # Create a POS order with an invoice and a linked customer
            pos_order_with_invoice = self._create_order({
                'pos_order_lines_ui_args': [
                    (self.product_a, 3.0),  # 3 units of product A
                    (self.product_b, 3.0),  # 3 units of product B
                ],
                'payments': [(self.bank_pm1, 945.0)],  # Payment of 945 through bank payment method
                'customer': self.partner_a,
            })

            # Generate an invoice for the POS order with an invoice
            pos_order_with_invoice._generate_pos_order_invoice()

        # Generate Document Summary for the following gstr report.
        self.gstr1_report.action_generate_document_summary()

        # Retrieve the GSTR1 JSON report generated by POS session closure
        generated_gstr1_json = self.gstr1_report._get_l10n_in_gstr1_json()

        # Assert that the generated JSON matches the expected response
        expected_gstr1_pos_invoice_order_response = self._read_mock_json('gstr1_pos_invoice_order_expected_response.json')
        self.assertDictEqual(generated_gstr1_json, expected_gstr1_pos_invoice_order_response)

    @freeze_time('2023-05-20')
    def test_gstr1_json_generation_with_pos_order_invoice_in_different_session(self):
        """Test GSTR1 JSON generation with POS invoice and order closure."""
        with self.with_pos_session():
            # Create a POS order without an invoice, simulating basic sale and payment
            self._create_order(
                {
                    'pos_order_lines_ui_args': [
                        (self.product_a, 2.0),  # 2 units of product A
                        (self.product_b, 2.0),  # 2 units of product B
                    ],
                    'payments': [(self.bank_pm1, 630.0)],  # Payment of 630 through bank payment method
                })
            going_to_invoice_order_in_next_session = self._create_order({
                'pos_order_lines_ui_args': [
                    (self.product_a, 3.0),  # 3 units of product A
                    (self.product_b, 3.0),  # 3 units of product B
                ],
                'payments': [(self.bank_pm1, 945.0)],  # Payment of 945 through bank payment method
                'customer': self.partner_a,
            })

        with self.with_pos_session():
            # Create a POS order without an invoice, simulating basic sale and payment
            self._create_order(
                {
                    'pos_order_lines_ui_args': [
                        (self.product_a, 2.0),  # 2 units of product A
                        (self.product_b, 2.0),  # 2 units of product B
                    ],
                    'payments': [(self.bank_pm1, 630.0)],  # Payment of 630 through bank payment method
                }
            )
            going_to_invoice_order_in_next_session._generate_pos_order_invoice()

        # Retrieve the GSTR1 JSON report generated by POS session closure
        generated_gstr1_json = self.gstr1_report._get_l10n_in_gstr1_json()

        # Assert that the generated JSON matches the expected response
        expected_gstr1_pos_order_invoice_in_different_session = self._read_mock_json('gstr1_pos_order_invoice_in_different_session_expected_response.json')
        self.assertDictEqual(generated_gstr1_json, expected_gstr1_pos_order_invoice_in_different_session)

    @freeze_time('2025-05-20')
    def test_gstr1_json_generation_with_pos_refund_order_for_new_hsn_schema(self):
        """Test case for partial refund and GSTR1 JSON generation."""
        with self.with_pos_session():
            # Step 1: Create an order with two products
            order = self._create_order({
                'pos_order_lines_ui_args': [
                    (self.product_a, 2.0),  # Buying 2 units of product_a
                    (self.product_b, 2.0),  # Buying 2 units of product_b
                ],
                'payments': [(self.bank_pm1, 630.0)],  # Payment of 630
            })

            # Step 2: Create a refund for one product line
            self._create_order({
                'pos_order_lines_ui_args': [
                    {
                        'product': self.product_b,
                        'quantity': -1.0,  # Refund 1 unit of product_b
                        'refunded_orderline_id': order.lines[1].id,
                    },
                ],
                'payments': [(self.bank_pm1, -210.0)],  # Refund of 210
            })

        # Retrieve the GSTR1 JSON report generated by POS session closure
        generated_gstr1_json = self.gstr1_report_may_2025._get_l10n_in_gstr1_json()

        # Assert GSTR1 JSON matches the expected data
        expected_gstr1_pos_refund_response = self._read_mock_json('gstr1_pos_refund_expected_updated_hsn_schema_response.json')
        self.assertDictEqual(generated_gstr1_json, expected_gstr1_pos_refund_response)

    @freeze_time('2025-05-20')
    def test_gstr1_json_generation_with_pos_order_invoice_for_new_hsn_schema(self):
        """Test GSTR1 JSON generation with POS invoice and order closure."""
        with self.with_pos_session():
            # Create a POS order without an invoice, simulating basic sale and payment
            self._create_order({
                'pos_order_lines_ui_args': [
                    (self.product_a, 2.0),  # 2 units of product A
                    (self.product_b, 2.0),  # 2 units of product B
                ],
                'payments': [(self.bank_pm1, 630.0)],  # Payment of 630 through bank payment method
            })
            # Create a POS order with an invoice and a linked customer
            pos_order_with_invoice = self._create_order({
                'pos_order_lines_ui_args': [
                    (self.product_a, 3.0),  # 3 units of product A
                    (self.product_b, 3.0),  # 3 units of product B
                ],
                'payments': [(self.bank_pm1, 945.0)],  # Payment of 945 through bank payment method
                'customer': self.partner_a,
            })

            # Generate an invoice for the POS order with an invoice
            pos_order_with_invoice._generate_pos_order_invoice()

        # Retrieve the GSTR1 JSON report generated by POS session closure
        generated_gstr1_json = self.gstr1_report_may_2025._get_l10n_in_gstr1_json()

        # Assert that the generated JSON matches the expected response
        expected_gstr1_pos_invoice_order_response = self._read_mock_json('gstr1_pos_invoice_order_expected_updated_hsn_schema_response.json')
        self.assertDictEqual(generated_gstr1_json, expected_gstr1_pos_invoice_order_response)

    @freeze_time('2025-05-20')
    def test_gstr1_json_generation_with_pos_order_invoice_in_different_session_for_new_hsn_schema(self):
        """Test GSTR1 JSON generation with POS invoice and order closure."""
        with self.with_pos_session():
            # Create a POS order without an invoice, simulating basic sale and payment
            self._create_order(
                {
                    'pos_order_lines_ui_args': [
                        (self.product_a, 2.0),  # 2 units of product A
                        (self.product_b, 2.0),  # 2 units of product B
                    ],
                    'payments': [(self.bank_pm1, 630.0)],  # Payment of 630 through bank payment method
                })
            going_to_invoice_order_in_next_session = self._create_order({
                'pos_order_lines_ui_args': [
                    (self.product_a, 3.0),  # 3 units of product A
                    (self.product_b, 3.0),  # 3 units of product B
                ],
                'payments': [(self.bank_pm1, 945.0)],  # Payment of 945 through bank payment method
                'customer': self.partner_a,
            })

        with self.with_pos_session():
            # Create a POS order without an invoice, simulating basic sale and payment
            self._create_order(
                {
                    'pos_order_lines_ui_args': [
                        (self.product_a, 2.0),  # 2 units of product A
                        (self.product_b, 2.0),  # 2 units of product B
                    ],
                    'payments': [(self.bank_pm1, 630.0)],  # Payment of 630 through bank payment method
                }
            )
            going_to_invoice_order_in_next_session._generate_pos_order_invoice()

        # Retrieve the GSTR1 JSON report generated by POS session closure
        generated_gstr1_json = self.gstr1_report_may_2025._get_l10n_in_gstr1_json()

        # Assert that the generated JSON matches the expected response
        expected_gstr1_pos_order_invoice_in_different_session = self._read_mock_json('gstr1_pos_order_invoice_in_different_session_expected_updated_hsn_schema_response.json')
        self.assertDictEqual(generated_gstr1_json, expected_gstr1_pos_order_invoice_in_different_session)

    @freeze_time('2025-05-20')
    def test_gstr1_json_with_closing_entry_by_product(self):
        product_with_same_hsn = self.env['product.product'].create({
            'name': 'Product with same HSN as A',
            'available_in_pos': True,
            'l10n_in_hsn_code': '1111',
            'list_price': 100,
            'taxes_id': [Command.set(self.gst_5.ids)],  # Tax: 5
        })
        order_info = {
            'pos_order_lines_ui_args': [
                (self.product_a, 2.0),  # 2 units of product A
                (self.product_b, 2.0),  # 2 units of product B
                (product_with_same_hsn, 1.0),  # 2 units of product with same HSN as A
            ],
            'payments': [(self.bank_pm1, 735.0)],  # Payment of 630 through bank payment method
        }
        self.config.is_closing_entry_by_product = True
        with self.with_pos_session():
            self._create_order(order_info)
            order_with_invoice = self._create_order({
                **order_info,
                'customer': self.partner_a,
            })
            order_with_invoice._generate_pos_order_invoice()
            order_going_to_refund = self._create_order(order_info)
            order_going_to_invoice = self._create_order(order_info)
            self._create_order({
                'pos_order_lines_ui_args': [
                    {
                        'product': self.product_b,
                        'quantity': -1.0,  # Refund 1 unit of product_b
                        'refunded_orderline_id': order_going_to_refund.lines[1].id,
                    },
                ],
                'payments': [(self.bank_pm1, -210.0)],  # Refund of 210
            })
        with self.with_pos_session():
            order_going_to_invoice.partner_id = self.partner_a
            order_going_to_invoice._generate_pos_order_invoice()

        # Retrieve the GSTR1 JSON report generated by POS session closure
        generated_gstr1_json = self.gstr1_report_may_2025._get_l10n_in_gstr1_json()
        expected_gstr1_pos_with_closing_entry_by_product = self._read_mock_json('gstr1_pos_with_closing_entry_by_product.json')
        self.assertDictEqual(generated_gstr1_json, expected_gstr1_pos_with_closing_entry_by_product)

    @freeze_time('2025-07-20')
    def test_gstr1_json_of_previous_period_updated_after_invoice_generated_in_later_month(self):
        """Ensure GSTR-1 JSON for previous period is updated after reversal in current period."""
        # Step 1: Setup partner details
        self.partner_a.write({
            'vat': '24ABCPM8965E1ZE',
            'state_id': self.env.ref("base.state_in_gj").id,
        })
        expected_gstr1_pos_response_old_period = self._read_mock_json('gstr1_pos_order_reversal_expected_response_previous_period.json')
        expected_gstr1_pos_response_current_period = self._read_mock_json('gstr1_pos_order_reversal_expected_response_current_period.json')
        # Step 2: Create POS orders under old return period (April)
        old_return_period_date = date(2025, 6, 19)
        with freeze_time(old_return_period_date):
            with self.with_pos_session():
                self._create_order({
                    'pos_order_lines_ui_args': [
                        (self.product_a, 2.0),
                        (self.product_b, 2.0),
                    ],
                    'payments': [(self.bank_pm1, 630.0)],
                })
                going_to_invoice_order_in_next_session = self._create_order({
                    'pos_order_lines_ui_args': [
                        (self.product_a, 2.0),
                        (self.product_b, 2.0),
                    ],
                    'payments': [(self.bank_pm1, 630.0)],
                    'customer': self.partner_a,
                })

        # Step 3: Generate and verify old GSTR1
        account_return_type = self.env.ref('l10n_in_reports.in_gstr1_return_type')
        return_company = self.company_data["company"]
        start_date, end_date = account_return_type._get_period_boundaries(return_company, old_return_period_date)
        old_return_period = self.env['account.return'].create({
            'name': 'Old Tax Return',
            'type_id': account_return_type.id,
            'company_id': return_company.id,
            'date_from': start_date,
            'date_to': end_date
        })
        old_return_period_json = old_return_period._get_l10n_in_gstr1_json()
        self.assertDictEqual(old_return_period_json, expected_gstr1_pos_response_old_period)

        # Step 4: Generate invoice for old order in current period
        going_to_invoice_order_in_next_session._generate_pos_order_invoice()

        # Step 5: Generate and verify current GSTR1
        current_return_period_date = date(2025, 7, 20)
        start_date, end_date = account_return_type._get_period_boundaries(return_company, current_return_period_date)
        current_return_period = self.env['account.return'].create({
            'name': 'Current Tax Return',
            'type_id': account_return_type.id,
            'company_id': return_company.id,
            'date_from': start_date,
            'date_to': end_date
        })
        current_gstr1_report_json = current_return_period._get_l10n_in_gstr1_json()
        self.assertDictEqual(current_gstr1_report_json, expected_gstr1_pos_response_current_period)

        # Step 6: Re-generate and verify updated old GSTR1 JSON
        updated_old_return_period_json = old_return_period._get_l10n_in_gstr1_json()
        self.assertDictEqual(updated_old_return_period_json, expected_gstr1_pos_response_old_period)

    @freeze_time('2023-05-20')
    def test_gstr1_service_product_json_generation(self):
        # Create a service-type product with GST tax (5%) and HSN code
        product_service = self.env['product.product'].create({
            'name': 'Service Product',
            'type': 'service',
            'lst_price': 100.0,
            'taxes_id': [Command.set(self.gst_5.ids)],  # Apply 5% GST tax
            'l10n_in_hsn_code': '9911',  # HSN code for services
        })

        with self.with_pos_session():
            self._create_order({
                'pos_order_lines_ui_args': [
                    (self.product_a, 2.0),       # Buying 2 units of product_a
                    (product_service, 2.0),      # Buying 2 units of service product
                ],
                'payments': [(self.bank_pm1, 420.0)],  # Payment amount of 420
            })

        # Retrieve the GSTR1 JSON report generated by POS session closure
        generated_gstr1_json = self.gstr1_report._get_l10n_in_gstr1_json()

        # Assert GSTR1 JSON matches the expected data
        expected_pos_service_product_gstr1_response = self._read_mock_json('gstr1_pos_service_product_gstr1_expected_response.json')
        self.assertDictEqual(generated_gstr1_json, expected_pos_service_product_gstr1_response)
